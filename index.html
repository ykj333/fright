<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 비행기 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: 'Inter', sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 8px;
        }
        #gameCanvas { display: block; }
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 0.9em;
            text-align: center;
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        .controls-info h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        .controls-info p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1 class="text-2xl font-bold">3D 비행기 시뮬레이션</h1>
        <p class="text-sm">Three.js를 사용한 간단한 예제</p>
    </div>

    <div class="controls-info">
        <h3>조작 방법</h3>
        <p><strong>W:</strong> 앞으로 이동 / 속도 증가</p>
        <p><strong>S:</strong> 뒤로 이동 / 속도 감소</p>
        <p><strong>A:</strong> 왼쪽으로 요 (Yaw Left)</p>
        <p><strong>D:</strong> 오른쪽으로 요 (Yaw Right)</p>
        <p><strong>↑ (화살표 위):</strong> 피치 다운 (기수 아래로)</p>
        <p><strong>↓ (화살표 아래):</strong> 피치 업 (기수 위로)</p>
        <p><strong>← (화살표 왼쪽):</strong> 왼쪽으로 롤 (Roll Left)</p>
        <p><strong>→ (화살표 오른쪽):</strong> 오른쪽으로 롤 (Roll Right)</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let airplane;
        let ground;

        // 비행기 상태 변수
        const airplaneState = {
            speed: 0.05,
            velocity: new THREE.Vector3(0, 0, 0),
            rollSpeed: 0, // 사용되지 않음, turnRate로 대체
            pitchSpeed: 0, // 사용되지 않음, turnRate로 대체
            yawSpeed: 0, // 사용되지 않음, turnRate로 대체
            maxSpeed: 0.5,
            minSpeed: 0.01,
            acceleration: 0.005,
            turnRate: 0.03, // 롤, 피치, 요 회전율
        };

        // 키보드 입력 상태
        const keysPressed = {};

        function init() {
            // 장면 생성
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // 하늘색 배경
            scene.fog = new THREE.Fog(0x87ceeb, 100, 500); // 안개 효과

            // 카메라 생성
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10); // 카메라 초기 위치

            // 렌더러 생성
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 그림자 활성화

            // 조명 추가
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // 전체적인 주변광
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // 태양광과 같은 직사광
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true; // 그림자 생성 설정
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            // 비행기 모델 생성
            createAirplane();

            // 지면 생성
            createGround();
            
            // 별 생성 (선택 사항)
            createStars();


            // 이벤트 리스너 등록
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            // 애니메이션 루프 시작
            animate();
        }

        function createAirplane() {
            airplane = new THREE.Group();

            // 동체 (Cylinder)
            // 오류 수정: 0xsilver -> 0xC0C0C0 (유효한 hex 값)
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.5, roughness: 0.5 });
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.3, 3, 16);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2; // 가로로 눕히기 (로컬 Z축이 앞쪽이 되도록)
            body.castShadow = true;
            airplane.add(body);

            // 주 날개 (Box)
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.5, roughness: 0.5 });
            const wingGeometry = new THREE.BoxGeometry(6, 0.2, 1.5); // width, height, depth
            const mainWing = new THREE.Mesh(wingGeometry, wingMaterial);
            mainWing.position.y = 0; // 동체 중심에 위치
            mainWing.castShadow = true;
            airplane.add(mainWing);

            // 꼬리 날개 - 수평 (Box)
            const tailWingGeometry = new THREE.BoxGeometry(2.5, 0.15, 0.8);
            const horizontalTailWing = new THREE.Mesh(tailWingGeometry, wingMaterial);
            horizontalTailWing.position.z = -1.8; // 동체 뒤쪽으로
            horizontalTailWing.position.y = 0.2; // 약간 위로
            horizontalTailWing.castShadow = true;
            airplane.add(horizontalTailWing);

            // 꼬리 날개 - 수직 (Box)
            const verticalTailWingGeometry = new THREE.BoxGeometry(0.15, 1, 0.8);
            const verticalTailWing = new THREE.Mesh(verticalTailWingGeometry, wingMaterial);
            verticalTailWing.position.z = -1.8; // 동체 뒤쪽으로
            verticalTailWing.position.y = 0.6; // 수평 꼬리 날개 위로
            verticalTailWing.castShadow = true;
            airplane.add(verticalTailWing);
            
            // 프로펠러 (선택 사항)
            const propellerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
            const propellerBladeGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.1); // 두께, 길이, 폭
            const propellerBlade1 = new THREE.Mesh(propellerBladeGeometry, propellerMaterial);
            propellerBlade1.position.z = 1.6; // 동체 앞쪽 (로컬 Z축 기준)
            const propellerBlade2 = propellerBlade1.clone();
            propellerBlade2.rotation.z = Math.PI / 2; // 90도 회전하여 십자 모양
            airplane.add(propellerBlade1);
            airplane.add(propellerBlade2);


            airplane.position.set(0, 2, 0); // 비행기 초기 위치 (공중)
            scene.add(airplane);
        }

        function createGround() {
            const groundTexture = new THREE.TextureLoader().load('https://placehold.co/1024x1024/34A853/FFFFFF?text=GroundTexture'); // 간단한 텍스처
            groundTexture.wrapS = THREE.RepeatWrapping;
            groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(50, 50); // 텍스처 반복

            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: groundTexture,
                roughness: 0.9, 
                metalness: 0.1 
            });
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000); // 넓은 지면
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // 바닥으로 눕히기
            ground.position.y = -5; // 비행기 아래에 위치
            ground.receiveShadow = true; // 그림자 받기
            scene.add(ground);
        }
        
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });

            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2000); // -1000 to 1000
                const y = THREE.MathUtils.randFloatSpread(2000);
                const z = THREE.MathUtils.randFloatSpread(2000);
                if (Math.sqrt(x*x + y*y + z*z) > 100) { // Avoid stars too close to center
                     starVertices.push(x, y, z);
                }
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }


        function onKeyDown(event) {
            keysPressed[event.key.toLowerCase()] = true;
            keysPressed[event.code] = true; // Arrow keys use event.code
        }

        function onKeyUp(event) {
            keysPressed[event.key.toLowerCase()] = false;
            keysPressed[event.code] = false;
        }

        function updateAirplane() {
            // 속도 조절
            if (keysPressed['w']) {
                airplaneState.speed = Math.min(airplaneState.maxSpeed, airplaneState.speed + airplaneState.acceleration);
            }
            if (keysPressed['s']) {
                airplaneState.speed = Math.max(airplaneState.minSpeed, airplaneState.speed - airplaneState.acceleration);
            }

            // 회전 (Roll, Pitch, Yaw)
            // Roll (좌우 기울기): 왼쪽/오른쪽 화살표 - 비행기의 로컬 Z축 기준 회전
            if (keysPressed['ArrowLeft']) {
                airplane.rotateZ(airplaneState.turnRate); // 왼쪽으로 롤
            }
            if (keysPressed['ArrowRight']) {
                airplane.rotateZ(-airplaneState.turnRate); // 오른쪽으로 롤
            }

            // Pitch (상하 기울기): 위/아래 화살표 - 비행기의 로컬 X축 기준 회전
            if (keysPressed['ArrowUp']) { // 기수 아래로
                airplane.rotateX(airplaneState.turnRate);
            }
            if (keysPressed['ArrowDown']) { // 기수 위로
                airplane.rotateX(-airplaneState.turnRate);
            }
            
            // Yaw (좌우 방향 전환): A/D 키 - 비행기의 로컬 Y축 기준 회전
            if (keysPressed['a']) {
                airplane.rotateY(airplaneState.turnRate); // 왼쪽으로 요
            }
            if (keysPressed['d']) {
                airplane.rotateY(-airplaneState.turnRate); // 오른쪽으로 요
            }


            // 비행기 전진 방향 벡터 계산 (로컬 -Z 축이 앞쪽)
            const forward = new THREE.Vector3(0, 0, -1); 
            forward.applyQuaternion(airplane.quaternion); // 비행기의 현재 회전을 적용하여 월드 방향 벡터 얻기
            
            // 비행기 이동
            airplane.position.addScaledVector(forward, airplaneState.speed);

            // 간단한 고도 유지 (지면 아래로 못가게)
            if (airplane.position.y < ground.position.y + 1) {
                airplane.position.y = ground.position.y + 1;
            }
            
            // 카메라가 비행기를 따라다니도록 설정
            const cameraOffset = new THREE.Vector3(0, 2, 7); // 카메라 오프셋 (비행기 로컬 좌표 기준: 뒤쪽 약간 위)
            const worldOffset = cameraOffset.clone().applyMatrix4(airplane.matrixWorld); // 월드 좌표로 변환
            
            camera.position.lerp(worldOffset, 0.1); // 카메라 위치 부드럽게 이동
            camera.lookAt(airplane.position); // 항상 비행기를 바라보도록
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateAirplane();

            // 프로펠러 회전 (선택 사항)
            if (airplane && airplane.children.length > 4) { // 프로펠러가 추가되었다고 가정 (동체, 주날개, 수평꼬리, 수직꼬리 + 프로펠러2개)
                // 프로펠러 식별을 좀 더 견고하게 할 수 있지만, 여기서는 순서에 의존
                const propellerBlade1 = airplane.children[4]; 
                const propellerBlade2 = airplane.children[5];
                if(propellerBlade1) propellerBlade1.rotation.z += airplaneState.speed * 5; // 속도에 따라 회전 속도 변경
                if(propellerBlade2) propellerBlade2.rotation.z += airplaneState.speed * 5;
            }


            renderer.render(scene, camera);
        }

        // 초기화 함수 호출
        init();
    </script>
</body>
</html>